{"ast":null,"code":"export const getExtremumX = params => {\n  var _axis$data, _axis$data2;\n  const {\n    axis\n  } = params;\n  const minX = Math.min(...((_axis$data = axis.data) !== null && _axis$data !== void 0 ? _axis$data : []));\n  const maxX = Math.max(...((_axis$data2 = axis.data) !== null && _axis$data2 !== void 0 ? _axis$data2 : []));\n  return [minX, maxX];\n};\nfunction getSeriesExtremums(getValues, stackedData, filter) {\n  return stackedData.reduce((seriesAcc, stackedValue, index) => {\n    const [base, value] = getValues(stackedValue);\n    if (filter && (!filter({\n      y: base,\n      x: null\n    }, index) || !filter({\n      y: value,\n      x: null\n    }, index))) {\n      return seriesAcc;\n    }\n    return [Math.min(base, value, seriesAcc[0]), Math.max(base, value, seriesAcc[1])];\n  }, [Infinity, -Infinity]);\n}\nexport const getExtremumY = params => {\n  const {\n    series,\n    axis,\n    isDefaultAxis,\n    getFilters\n  } = params;\n  return Object.keys(series).filter(seriesId => {\n    var _series$seriesId$yAxi;\n    const yAxisId = (_series$seriesId$yAxi = series[seriesId].yAxisId) !== null && _series$seriesId$yAxi !== void 0 ? _series$seriesId$yAxi : series[seriesId].yAxisKey;\n    return yAxisId === axis.id || isDefaultAxis && yAxisId === undefined;\n  }).reduce((acc, seriesId) => {\n    var _series$seriesId$xAxi, _series$seriesId$yAxi2;\n    const {\n      area,\n      stackedData\n    } = series[seriesId];\n    const isArea = area !== undefined;\n    const filter = getFilters === null || getFilters === void 0 ? void 0 : getFilters({\n      currentAxisId: axis.id,\n      isDefaultAxis,\n      seriesXAxisId: (_series$seriesId$xAxi = series[seriesId].xAxisId) !== null && _series$seriesId$xAxi !== void 0 ? _series$seriesId$xAxi : series[seriesId].xAxisKey,\n      seriesYAxisId: (_series$seriesId$yAxi2 = series[seriesId].yAxisId) !== null && _series$seriesId$yAxi2 !== void 0 ? _series$seriesId$yAxi2 : series[seriesId].yAxisKey\n    });\n\n    // Since this series is not used to display an area, we do not consider the base (the d[0]).\n    const getValues = isArea && axis.scaleType !== 'log' && typeof series[seriesId].baseline !== 'string' ? d => d : d => [d[1], d[1]];\n    const seriesExtremums = getSeriesExtremums(getValues, stackedData, filter);\n    const [seriesMin, seriesMax] = seriesExtremums;\n    return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];\n  }, [Infinity, -Infinity]);\n};","map":{"version":3,"names":["getExtremumX","params","_axis$data","_axis$data2","axis","minX","Math","min","data","maxX","max","getSeriesExtremums","getValues","stackedData","filter","reduce","seriesAcc","stackedValue","index","base","value","y","x","Infinity","getExtremumY","series","isDefaultAxis","getFilters","Object","keys","seriesId","_series$seriesId$yAxi","yAxisId","yAxisKey","id","undefined","acc","_series$seriesId$xAxi","_series$seriesId$yAxi2","area","isArea","currentAxisId","seriesXAxisId","xAxisId","xAxisKey","seriesYAxisId","scaleType","baseline","d","seriesExtremums","seriesMin","seriesMax"],"sources":["C:/narendra/Reactjs/Frontend/node_modules/@mui/x-charts/LineChart/extremums.js"],"sourcesContent":["export const getExtremumX = params => {\n  const {\n    axis\n  } = params;\n  const minX = Math.min(...(axis.data ?? []));\n  const maxX = Math.max(...(axis.data ?? []));\n  return [minX, maxX];\n};\nfunction getSeriesExtremums(getValues, stackedData, filter) {\n  return stackedData.reduce((seriesAcc, stackedValue, index) => {\n    const [base, value] = getValues(stackedValue);\n    if (filter && (!filter({\n      y: base,\n      x: null\n    }, index) || !filter({\n      y: value,\n      x: null\n    }, index))) {\n      return seriesAcc;\n    }\n    return [Math.min(base, value, seriesAcc[0]), Math.max(base, value, seriesAcc[1])];\n  }, [Infinity, -Infinity]);\n}\nexport const getExtremumY = params => {\n  const {\n    series,\n    axis,\n    isDefaultAxis,\n    getFilters\n  } = params;\n  return Object.keys(series).filter(seriesId => {\n    const yAxisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey;\n    return yAxisId === axis.id || isDefaultAxis && yAxisId === undefined;\n  }).reduce((acc, seriesId) => {\n    const {\n      area,\n      stackedData\n    } = series[seriesId];\n    const isArea = area !== undefined;\n    const filter = getFilters?.({\n      currentAxisId: axis.id,\n      isDefaultAxis,\n      seriesXAxisId: series[seriesId].xAxisId ?? series[seriesId].xAxisKey,\n      seriesYAxisId: series[seriesId].yAxisId ?? series[seriesId].yAxisKey\n    });\n\n    // Since this series is not used to display an area, we do not consider the base (the d[0]).\n    const getValues = isArea && axis.scaleType !== 'log' && typeof series[seriesId].baseline !== 'string' ? d => d : d => [d[1], d[1]];\n    const seriesExtremums = getSeriesExtremums(getValues, stackedData, filter);\n    const [seriesMin, seriesMax] = seriesExtremums;\n    return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];\n  }, [Infinity, -Infinity]);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
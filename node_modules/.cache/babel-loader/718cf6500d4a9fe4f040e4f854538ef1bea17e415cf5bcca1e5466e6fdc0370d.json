{"ast":null,"code":"const createResult = (data, direction) => {\n  if (direction === 'x') {\n    return {\n      x: data,\n      y: null\n    };\n  }\n  return {\n    x: null,\n    y: data\n  };\n};\nconst getBaseExtremum = params => {\n  var _axis$data;\n  const {\n    axis,\n    getFilters,\n    isDefaultAxis\n  } = params;\n  const filter = getFilters === null || getFilters === void 0 ? void 0 : getFilters({\n    currentAxisId: axis.id,\n    isDefaultAxis\n  });\n  const data = filter ? (_axis$data = axis.data) === null || _axis$data === void 0 ? void 0 : _axis$data.filter((_, i) => filter({\n    x: null,\n    y: null\n  }, i)) : axis.data;\n  const minX = Math.min(...(data !== null && data !== void 0 ? data : []));\n  const maxX = Math.max(...(data !== null && data !== void 0 ? data : []));\n  return [minX, maxX];\n};\nconst getValueExtremum = direction => params => {\n  const {\n    series,\n    axis,\n    getFilters,\n    isDefaultAxis\n  } = params;\n  return Object.keys(series).filter(seriesId => {\n    var _series$seriesId$yAxi;\n    const yAxisId = (_series$seriesId$yAxi = series[seriesId].yAxisId) !== null && _series$seriesId$yAxi !== void 0 ? _series$seriesId$yAxi : series[seriesId].yAxisKey;\n    return yAxisId === axis.id || isDefaultAxis && yAxisId === undefined;\n  }).reduce((acc, seriesId) => {\n    var _series$seriesId$xAxi, _series$seriesId$yAxi2, _stackedData$reduce;\n    const {\n      stackedData\n    } = series[seriesId];\n    const filter = getFilters === null || getFilters === void 0 ? void 0 : getFilters({\n      currentAxisId: axis.id,\n      isDefaultAxis,\n      seriesXAxisId: (_series$seriesId$xAxi = series[seriesId].xAxisId) !== null && _series$seriesId$xAxi !== void 0 ? _series$seriesId$xAxi : series[seriesId].xAxisKey,\n      seriesYAxisId: (_series$seriesId$yAxi2 = series[seriesId].yAxisId) !== null && _series$seriesId$yAxi2 !== void 0 ? _series$seriesId$yAxi2 : series[seriesId].yAxisKey\n    });\n    const [seriesMin, seriesMax] = (_stackedData$reduce = stackedData === null || stackedData === void 0 ? void 0 : stackedData.reduce((seriesAcc, values, index) => {\n      if (filter && (!filter(createResult(values[0], direction), index) || !filter(createResult(values[1], direction), index))) {\n        return seriesAcc;\n      }\n      return [Math.min(...values, seriesAcc[0]), Math.max(...values, seriesAcc[1])];\n    }, [Infinity, -Infinity])) !== null && _stackedData$reduce !== void 0 ? _stackedData$reduce : [Infinity, -Infinity];\n    return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];\n  }, [Infinity, -Infinity]);\n};\nexport const getExtremumX = params => {\n  // Notice that bar should be all horizontal or all vertical.\n  // Don't think it's a problem for now\n  const isHorizontal = Object.keys(params.series).some(seriesId => params.series[seriesId].layout === 'horizontal');\n  if (isHorizontal) {\n    return getValueExtremum('x')(params);\n  }\n  return getBaseExtremum(params);\n};\nexport const getExtremumY = params => {\n  const isHorizontal = Object.keys(params.series).some(seriesId => params.series[seriesId].layout === 'horizontal');\n  if (isHorizontal) {\n    return getBaseExtremum(params);\n  }\n  return getValueExtremum('y')(params);\n};","map":{"version":3,"names":["createResult","data","direction","x","y","getBaseExtremum","params","_axis$data","axis","getFilters","isDefaultAxis","filter","currentAxisId","id","_","i","minX","Math","min","maxX","max","getValueExtremum","series","Object","keys","seriesId","_series$seriesId$yAxi","yAxisId","yAxisKey","undefined","reduce","acc","_series$seriesId$xAxi","_series$seriesId$yAxi2","_stackedData$reduce","stackedData","seriesXAxisId","xAxisId","xAxisKey","seriesYAxisId","seriesMin","seriesMax","seriesAcc","values","index","Infinity","getExtremumX","isHorizontal","some","layout","getExtremumY"],"sources":["C:/narendra/Reactjs/Frontend/node_modules/@mui/x-charts/BarChart/extremums.js"],"sourcesContent":["const createResult = (data, direction) => {\n  if (direction === 'x') {\n    return {\n      x: data,\n      y: null\n    };\n  }\n  return {\n    x: null,\n    y: data\n  };\n};\nconst getBaseExtremum = params => {\n  const {\n    axis,\n    getFilters,\n    isDefaultAxis\n  } = params;\n  const filter = getFilters?.({\n    currentAxisId: axis.id,\n    isDefaultAxis\n  });\n  const data = filter ? axis.data?.filter((_, i) => filter({\n    x: null,\n    y: null\n  }, i)) : axis.data;\n  const minX = Math.min(...(data ?? []));\n  const maxX = Math.max(...(data ?? []));\n  return [minX, maxX];\n};\nconst getValueExtremum = direction => params => {\n  const {\n    series,\n    axis,\n    getFilters,\n    isDefaultAxis\n  } = params;\n  return Object.keys(series).filter(seriesId => {\n    const yAxisId = series[seriesId].yAxisId ?? series[seriesId].yAxisKey;\n    return yAxisId === axis.id || isDefaultAxis && yAxisId === undefined;\n  }).reduce((acc, seriesId) => {\n    const {\n      stackedData\n    } = series[seriesId];\n    const filter = getFilters?.({\n      currentAxisId: axis.id,\n      isDefaultAxis,\n      seriesXAxisId: series[seriesId].xAxisId ?? series[seriesId].xAxisKey,\n      seriesYAxisId: series[seriesId].yAxisId ?? series[seriesId].yAxisKey\n    });\n    const [seriesMin, seriesMax] = stackedData?.reduce((seriesAcc, values, index) => {\n      if (filter && (!filter(createResult(values[0], direction), index) || !filter(createResult(values[1], direction), index))) {\n        return seriesAcc;\n      }\n      return [Math.min(...values, seriesAcc[0]), Math.max(...values, seriesAcc[1])];\n    }, [Infinity, -Infinity]) ?? [Infinity, -Infinity];\n    return [Math.min(seriesMin, acc[0]), Math.max(seriesMax, acc[1])];\n  }, [Infinity, -Infinity]);\n};\nexport const getExtremumX = params => {\n  // Notice that bar should be all horizontal or all vertical.\n  // Don't think it's a problem for now\n  const isHorizontal = Object.keys(params.series).some(seriesId => params.series[seriesId].layout === 'horizontal');\n  if (isHorizontal) {\n    return getValueExtremum('x')(params);\n  }\n  return getBaseExtremum(params);\n};\nexport const getExtremumY = params => {\n  const isHorizontal = Object.keys(params.series).some(seriesId => params.series[seriesId].layout === 'horizontal');\n  if (isHorizontal) {\n    return getBaseExtremum(params);\n  }\n  return getValueExtremum('y')(params);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
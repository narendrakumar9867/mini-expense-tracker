{"ast":null,"code":"import { getAxisExtremum, isDefined, getScale } from '@mui/x-charts/internals';\nexport const createAxisFilterMapper = ({\n  zoomData,\n  extremumGetter,\n  formattedSeries,\n  direction\n}) => (axis, axisIndex) => {\n  if (typeof axis.zoom !== 'object' || axis.zoom.filterMode !== 'discard') {\n    return null;\n  }\n  const zoom = zoomData?.find(({\n    axisId\n  }) => axisId === axis.id);\n  if (zoom === undefined || zoom.start <= 0 && zoom.end >= 100) {\n    // No zoom, or zoom with all data visible\n    return null;\n  }\n  let extremums = [];\n  const scaleType = axis.scaleType;\n  if (scaleType === 'point' || scaleType === 'band') {\n    extremums = [0, (axis.data?.length ?? 1) - 1];\n  } else {\n    extremums = getAxisExtremum(axis, extremumGetter, axisIndex, formattedSeries);\n  }\n  let min;\n  let max;\n\n  // @ts-expect-error The function defaults to linear scale if the scaleType is not recognized.\n  [min, max] = getScale(scaleType, extremums, [0, 100]).nice().domain();\n  min = min instanceof Date ? min.getTime() : min;\n  max = max instanceof Date ? max.getTime() : max;\n  const minVal = min + zoom.start * (max - min) / 100;\n  const maxVal = min + zoom.end * (max - min) / 100;\n  return (value, dataIndex) => {\n    const val = value[direction] ?? axis.data?.[dataIndex];\n    if (val == null) {\n      // If the value does not exist because of missing data point, or out of range index, we just ignore.\n      return true;\n    }\n    if (axis.scaleType === 'point' || axis.scaleType === 'band' || typeof val === 'string') {\n      return dataIndex >= minVal && dataIndex <= maxVal;\n    }\n    return val >= minVal && val <= maxVal;\n  };\n};\nexport const createGetAxisFilters = filters => ({\n  currentAxisId,\n  seriesXAxisId,\n  seriesYAxisId,\n  isDefaultAxis\n}) => {\n  return (value, dataIndex) => {\n    const axisId = currentAxisId === seriesXAxisId ? seriesYAxisId : seriesXAxisId;\n    if (!axisId || isDefaultAxis) {\n      return Object.values(filters ?? {})[0]?.(value, dataIndex) ?? true;\n    }\n    const data = [seriesYAxisId, seriesXAxisId].filter(id => id !== currentAxisId).map(id => filters[id ?? '']).filter(isDefined);\n    return data.every(f => f(value, dataIndex));\n  };\n};","map":{"version":3,"names":["getAxisExtremum","isDefined","getScale","createAxisFilterMapper","zoomData","extremumGetter","formattedSeries","direction","axis","axisIndex","zoom","filterMode","find","axisId","id","undefined","start","end","extremums","scaleType","data","length","min","max","nice","domain","Date","getTime","minVal","maxVal","value","dataIndex","val","createGetAxisFilters","filters","currentAxisId","seriesXAxisId","seriesYAxisId","isDefaultAxis","Object","values","filter","map","every","f"],"sources":["C:/narendra/Reactjs/mini-expense-tracker/node_modules/@mui/x-charts-pro/context/CartesianProviderPro/createAxisFilterMapper.js"],"sourcesContent":["import { getAxisExtremum, isDefined, getScale } from '@mui/x-charts/internals';\nexport const createAxisFilterMapper = ({\n  zoomData,\n  extremumGetter,\n  formattedSeries,\n  direction\n}) => (axis, axisIndex) => {\n  if (typeof axis.zoom !== 'object' || axis.zoom.filterMode !== 'discard') {\n    return null;\n  }\n  const zoom = zoomData?.find(({\n    axisId\n  }) => axisId === axis.id);\n  if (zoom === undefined || zoom.start <= 0 && zoom.end >= 100) {\n    // No zoom, or zoom with all data visible\n    return null;\n  }\n  let extremums = [];\n  const scaleType = axis.scaleType;\n  if (scaleType === 'point' || scaleType === 'band') {\n    extremums = [0, (axis.data?.length ?? 1) - 1];\n  } else {\n    extremums = getAxisExtremum(axis, extremumGetter, axisIndex, formattedSeries);\n  }\n  let min;\n  let max;\n\n  // @ts-expect-error The function defaults to linear scale if the scaleType is not recognized.\n  [min, max] = getScale(scaleType, extremums, [0, 100]).nice().domain();\n  min = min instanceof Date ? min.getTime() : min;\n  max = max instanceof Date ? max.getTime() : max;\n  const minVal = min + zoom.start * (max - min) / 100;\n  const maxVal = min + zoom.end * (max - min) / 100;\n  return (value, dataIndex) => {\n    const val = value[direction] ?? axis.data?.[dataIndex];\n    if (val == null) {\n      // If the value does not exist because of missing data point, or out of range index, we just ignore.\n      return true;\n    }\n    if (axis.scaleType === 'point' || axis.scaleType === 'band' || typeof val === 'string') {\n      return dataIndex >= minVal && dataIndex <= maxVal;\n    }\n    return val >= minVal && val <= maxVal;\n  };\n};\nexport const createGetAxisFilters = filters => ({\n  currentAxisId,\n  seriesXAxisId,\n  seriesYAxisId,\n  isDefaultAxis\n}) => {\n  return (value, dataIndex) => {\n    const axisId = currentAxisId === seriesXAxisId ? seriesYAxisId : seriesXAxisId;\n    if (!axisId || isDefaultAxis) {\n      return Object.values(filters ?? {})[0]?.(value, dataIndex) ?? true;\n    }\n    const data = [seriesYAxisId, seriesXAxisId].filter(id => id !== currentAxisId).map(id => filters[id ?? '']).filter(isDefined);\n    return data.every(f => f(value, dataIndex));\n  };\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useDrawingArea, useSvgRef } from '@mui/x-charts/hooks';\nimport { getSVGPoint } from '@mui/x-charts/internals';\nimport { useZoom } from \"./useZoom.js\";\nexport const useSetupPan = () => {\n  const {\n    zoomData,\n    setZoomData,\n    setIsInteracting,\n    isPanEnabled,\n    options\n  } = useZoom();\n  const drawingArea = useDrawingArea();\n  const svgRef = useSvgRef();\n  const isDraggingRef = React.useRef(false);\n  const touchStartRef = React.useRef(null);\n  const eventCacheRef = React.useRef([]);\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null || !isPanEnabled) {\n      return () => {};\n    }\n    const handlePan = event => {\n      if (element === null || !isDraggingRef.current || eventCacheRef.current.length > 1) {\n        return;\n      }\n      if (touchStartRef.current == null) {\n        return;\n      }\n      const point = getSVGPoint(element, event);\n      const movementX = point.x - touchStartRef.current.x;\n      const movementY = (point.y - touchStartRef.current.y) * -1;\n      const newZoomData = touchStartRef.current.zoomData.map(zoom => {\n        const option = options[zoom.axisId];\n        if (!option || !option.panning) {\n          return zoom;\n        }\n        const min = zoom.start;\n        const max = zoom.end;\n        const span = max - min;\n        const MIN_PERCENT = option.minStart;\n        const MAX_PERCENT = option.maxEnd;\n        const movement = option.axisDirection === 'x' ? movementX : movementY;\n        const dimension = option.axisDirection === 'x' ? drawingArea.width : drawingArea.height;\n        let newMinPercent = min - movement / dimension * span;\n        let newMaxPercent = max - movement / dimension * span;\n        if (newMinPercent < MIN_PERCENT) {\n          newMinPercent = MIN_PERCENT;\n          newMaxPercent = newMinPercent + span;\n        }\n        if (newMaxPercent > MAX_PERCENT) {\n          newMaxPercent = MAX_PERCENT;\n          newMinPercent = newMaxPercent - span;\n        }\n        if (newMinPercent < MIN_PERCENT || newMaxPercent > MAX_PERCENT || span < option.minSpan || span > option.maxSpan) {\n          return zoom;\n        }\n        return _extends({}, zoom, {\n          start: newMinPercent,\n          end: newMaxPercent\n        });\n      });\n      setZoomData(newZoomData);\n    };\n    const handleDown = event => {\n      eventCacheRef.current.push(event);\n      const point = getSVGPoint(element, event);\n      if (!drawingArea.isPointInside(point)) {\n        return;\n      }\n\n      // If there is only one pointer, prevent selecting text\n      if (eventCacheRef.current.length === 1) {\n        event.preventDefault();\n      }\n      isDraggingRef.current = true;\n      setIsInteracting(true);\n      touchStartRef.current = {\n        x: point.x,\n        y: point.y,\n        zoomData\n      };\n    };\n    const handleUp = event => {\n      eventCacheRef.current.splice(eventCacheRef.current.findIndex(cachedEvent => cachedEvent.pointerId === event.pointerId), 1);\n      setIsInteracting(false);\n      isDraggingRef.current = false;\n      touchStartRef.current = null;\n    };\n    element.addEventListener('pointerdown', handleDown);\n    document.addEventListener('pointermove', handlePan);\n    document.addEventListener('pointerup', handleUp);\n    document.addEventListener('pointercancel', handleUp);\n    document.addEventListener('pointerleave', handleUp);\n    return () => {\n      element.removeEventListener('pointerdown', handleDown);\n      document.removeEventListener('pointermove', handlePan);\n      document.removeEventListener('pointerup', handleUp);\n      document.removeEventListener('pointercancel', handleUp);\n      document.removeEventListener('pointerleave', handleUp);\n    };\n  }, [drawingArea, svgRef, isDraggingRef, setIsInteracting, zoomData, setZoomData, isPanEnabled, options]);\n};","map":{"version":3,"names":["_extends","React","useDrawingArea","useSvgRef","getSVGPoint","useZoom","useSetupPan","zoomData","setZoomData","setIsInteracting","isPanEnabled","options","drawingArea","svgRef","isDraggingRef","useRef","touchStartRef","eventCacheRef","useEffect","element","current","handlePan","event","length","point","movementX","x","movementY","y","newZoomData","map","zoom","option","axisId","panning","min","start","max","end","span","MIN_PERCENT","minStart","MAX_PERCENT","maxEnd","movement","axisDirection","dimension","width","height","newMinPercent","newMaxPercent","minSpan","maxSpan","handleDown","push","isPointInside","preventDefault","handleUp","splice","findIndex","cachedEvent","pointerId","addEventListener","document","removeEventListener"],"sources":["C:/narendra/Reactjs/mini-expense-tracker/node_modules/@mui/x-charts-pro/context/ZoomProvider/useSetupPan.js"],"sourcesContent":["'use client';\n\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useDrawingArea, useSvgRef } from '@mui/x-charts/hooks';\nimport { getSVGPoint } from '@mui/x-charts/internals';\nimport { useZoom } from \"./useZoom.js\";\nexport const useSetupPan = () => {\n  const {\n    zoomData,\n    setZoomData,\n    setIsInteracting,\n    isPanEnabled,\n    options\n  } = useZoom();\n  const drawingArea = useDrawingArea();\n  const svgRef = useSvgRef();\n  const isDraggingRef = React.useRef(false);\n  const touchStartRef = React.useRef(null);\n  const eventCacheRef = React.useRef([]);\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null || !isPanEnabled) {\n      return () => {};\n    }\n    const handlePan = event => {\n      if (element === null || !isDraggingRef.current || eventCacheRef.current.length > 1) {\n        return;\n      }\n      if (touchStartRef.current == null) {\n        return;\n      }\n      const point = getSVGPoint(element, event);\n      const movementX = point.x - touchStartRef.current.x;\n      const movementY = (point.y - touchStartRef.current.y) * -1;\n      const newZoomData = touchStartRef.current.zoomData.map(zoom => {\n        const option = options[zoom.axisId];\n        if (!option || !option.panning) {\n          return zoom;\n        }\n        const min = zoom.start;\n        const max = zoom.end;\n        const span = max - min;\n        const MIN_PERCENT = option.minStart;\n        const MAX_PERCENT = option.maxEnd;\n        const movement = option.axisDirection === 'x' ? movementX : movementY;\n        const dimension = option.axisDirection === 'x' ? drawingArea.width : drawingArea.height;\n        let newMinPercent = min - movement / dimension * span;\n        let newMaxPercent = max - movement / dimension * span;\n        if (newMinPercent < MIN_PERCENT) {\n          newMinPercent = MIN_PERCENT;\n          newMaxPercent = newMinPercent + span;\n        }\n        if (newMaxPercent > MAX_PERCENT) {\n          newMaxPercent = MAX_PERCENT;\n          newMinPercent = newMaxPercent - span;\n        }\n        if (newMinPercent < MIN_PERCENT || newMaxPercent > MAX_PERCENT || span < option.minSpan || span > option.maxSpan) {\n          return zoom;\n        }\n        return _extends({}, zoom, {\n          start: newMinPercent,\n          end: newMaxPercent\n        });\n      });\n      setZoomData(newZoomData);\n    };\n    const handleDown = event => {\n      eventCacheRef.current.push(event);\n      const point = getSVGPoint(element, event);\n      if (!drawingArea.isPointInside(point)) {\n        return;\n      }\n\n      // If there is only one pointer, prevent selecting text\n      if (eventCacheRef.current.length === 1) {\n        event.preventDefault();\n      }\n      isDraggingRef.current = true;\n      setIsInteracting(true);\n      touchStartRef.current = {\n        x: point.x,\n        y: point.y,\n        zoomData\n      };\n    };\n    const handleUp = event => {\n      eventCacheRef.current.splice(eventCacheRef.current.findIndex(cachedEvent => cachedEvent.pointerId === event.pointerId), 1);\n      setIsInteracting(false);\n      isDraggingRef.current = false;\n      touchStartRef.current = null;\n    };\n    element.addEventListener('pointerdown', handleDown);\n    document.addEventListener('pointermove', handlePan);\n    document.addEventListener('pointerup', handleUp);\n    document.addEventListener('pointercancel', handleUp);\n    document.addEventListener('pointerleave', handleUp);\n    return () => {\n      element.removeEventListener('pointerdown', handleDown);\n      document.removeEventListener('pointermove', handlePan);\n      document.removeEventListener('pointerup', handleUp);\n      document.removeEventListener('pointercancel', handleUp);\n      document.removeEventListener('pointerleave', handleUp);\n    };\n  }, [drawingArea, svgRef, isDraggingRef, setIsInteracting, zoomData, setZoomData, isPanEnabled, options]);\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
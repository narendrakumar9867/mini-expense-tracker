{"ast":null,"code":"'use client';\n\nimport * as React from 'react';\nimport { useDrawingArea, useSvgRef } from '@mui/x-charts/hooks';\nimport { getSVGPoint } from '@mui/x-charts/internals';\nimport { useZoom } from \"./useZoom.js\";\n/**\n * Helper to get the range (in percents of a reference range) corresponding to a given scale.\n * @param centerRatio {number} The ratio of the point that should not move between the previous and next range.\n * @param scaleRatio {number} The target scale ratio.\n * @returns The range to display.\n */\nconst zoomAtPoint = (centerRatio, scaleRatio, currentZoomData, options) => {\n  const MIN_RANGE = options.minStart;\n  const MAX_RANGE = options.maxEnd;\n  const MIN_ALLOWED_SPAN = options.minSpan;\n  const minRange = currentZoomData.start;\n  const maxRange = currentZoomData.end;\n  const point = minRange + centerRatio * (maxRange - minRange);\n  let newMinRange = (minRange + point * (scaleRatio - 1)) / scaleRatio;\n  let newMaxRange = (maxRange + point * (scaleRatio - 1)) / scaleRatio;\n  let minSpillover = 0;\n  let maxSpillover = 0;\n  if (newMinRange < MIN_RANGE) {\n    minSpillover = Math.abs(newMinRange);\n    newMinRange = MIN_RANGE;\n  }\n  if (newMaxRange > MAX_RANGE) {\n    maxSpillover = Math.abs(newMaxRange - MAX_RANGE);\n    newMaxRange = MAX_RANGE;\n  }\n  if (minSpillover > 0 && maxSpillover > 0) {\n    return [MIN_RANGE, MAX_RANGE];\n  }\n  newMaxRange += minSpillover;\n  newMinRange -= maxSpillover;\n  newMinRange = Math.min(MAX_RANGE - MIN_ALLOWED_SPAN, Math.max(MIN_RANGE, newMinRange));\n  newMaxRange = Math.max(MIN_ALLOWED_SPAN, Math.min(MAX_RANGE, newMaxRange));\n  return [newMinRange, newMaxRange];\n};\nexport const useSetupZoom = () => {\n  const {\n    setZoomData,\n    isZoomEnabled,\n    options,\n    setIsInteracting\n  } = useZoom();\n  const drawingArea = useDrawingArea();\n  const svgRef = useSvgRef();\n  const eventCacheRef = React.useRef([]);\n  const eventPrevDiff = React.useRef(0);\n  const interactionTimeoutRef = React.useRef(undefined);\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null || !isZoomEnabled) {\n      return () => {};\n    }\n    const wheelHandler = event => {\n      if (element === null) {\n        return;\n      }\n      const point = getSVGPoint(element, event);\n      if (!drawingArea.isPointInside(point)) {\n        return;\n      }\n      event.preventDefault();\n      if (interactionTimeoutRef.current) {\n        clearTimeout(interactionTimeoutRef.current);\n      }\n      setIsInteracting(true);\n      // Debounce transition to `isInteractive=false`.\n      // Useful because wheel events don't have an \"end\" event.\n      interactionTimeoutRef.current = window.setTimeout(() => {\n        setIsInteracting(false);\n      }, 166);\n      setZoomData(prevZoomData => {\n        return prevZoomData.map(zoom => {\n          const option = options[zoom.axisId];\n          if (!option) {\n            return zoom;\n          }\n          const centerRatio = option.axisDirection === 'x' ? getHorizontalCenterRatio(point, drawingArea) : getVerticalCenterRatio(point, drawingArea);\n          const {\n            scaleRatio,\n            isZoomIn\n          } = getWheelScaleRatio(event, option.step);\n          const [newMinRange, newMaxRange] = zoomAtPoint(centerRatio, scaleRatio, zoom, option);\n          if (!isSpanValid(newMinRange, newMaxRange, isZoomIn, option)) {\n            return zoom;\n          }\n          return {\n            axisId: zoom.axisId,\n            start: newMinRange,\n            end: newMaxRange\n          };\n        });\n      });\n    };\n    function pointerDownHandler(event) {\n      eventCacheRef.current.push(event);\n      setIsInteracting(true);\n    }\n    function pointerMoveHandler(event) {\n      if (element === null) {\n        return;\n      }\n      const index = eventCacheRef.current.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);\n      eventCacheRef.current[index] = event;\n\n      // Not a pinch gesture\n      if (eventCacheRef.current.length !== 2) {\n        return;\n      }\n      const firstEvent = eventCacheRef.current[0];\n      const curDiff = getDiff(eventCacheRef.current);\n      setZoomData(prevZoomData => {\n        const newZoomData = prevZoomData.map(zoom => {\n          const option = options[zoom.axisId];\n          if (!option) {\n            return zoom;\n          }\n          const {\n            scaleRatio,\n            isZoomIn\n          } = getPinchScaleRatio(curDiff, eventPrevDiff.current, option.step);\n\n          // If the scale ratio is 0, it means the pinch gesture is not valid.\n          if (scaleRatio === 0) {\n            return zoom;\n          }\n          const point = getSVGPoint(element, firstEvent);\n          const centerRatio = option.axisDirection === 'x' ? getHorizontalCenterRatio(point, drawingArea) : getVerticalCenterRatio(point, drawingArea);\n          const [newMinRange, newMaxRange] = zoomAtPoint(centerRatio, scaleRatio, zoom, option);\n          if (!isSpanValid(newMinRange, newMaxRange, isZoomIn, option)) {\n            return zoom;\n          }\n          return {\n            axisId: zoom.axisId,\n            start: newMinRange,\n            end: newMaxRange\n          };\n        });\n        eventPrevDiff.current = curDiff;\n        return newZoomData;\n      });\n    }\n    function pointerUpHandler(event) {\n      eventCacheRef.current.splice(eventCacheRef.current.findIndex(cachedEvent => cachedEvent.pointerId === event.pointerId), 1);\n      if (eventCacheRef.current.length < 2) {\n        eventPrevDiff.current = 0;\n      }\n      if (event.type === 'pointerup' || event.type === 'pointercancel') {\n        setIsInteracting(false);\n      }\n    }\n    element.addEventListener('wheel', wheelHandler);\n    element.addEventListener('pointerdown', pointerDownHandler);\n    element.addEventListener('pointermove', pointerMoveHandler);\n    element.addEventListener('pointerup', pointerUpHandler);\n    element.addEventListener('pointercancel', pointerUpHandler);\n    element.addEventListener('pointerout', pointerUpHandler);\n    element.addEventListener('pointerleave', pointerUpHandler);\n\n    // Prevent zooming the entire page on touch devices\n    element.addEventListener('touchstart', preventDefault);\n    element.addEventListener('touchmove', preventDefault);\n    return () => {\n      element.removeEventListener('wheel', wheelHandler);\n      element.removeEventListener('pointerdown', pointerDownHandler);\n      element.removeEventListener('pointermove', pointerMoveHandler);\n      element.removeEventListener('pointerup', pointerUpHandler);\n      element.removeEventListener('pointercancel', pointerUpHandler);\n      element.removeEventListener('pointerout', pointerUpHandler);\n      element.removeEventListener('pointerleave', pointerUpHandler);\n      element.removeEventListener('touchstart', preventDefault);\n      element.removeEventListener('touchmove', preventDefault);\n      if (interactionTimeoutRef.current) {\n        clearTimeout(interactionTimeoutRef.current);\n      }\n    };\n  }, [svgRef, setZoomData, drawingArea, isZoomEnabled, options, setIsInteracting]);\n};\n\n/**\n * Checks if the new span is valid.\n */\nfunction isSpanValid(minRange, maxRange, isZoomIn, option) {\n  const newSpanPercent = maxRange - minRange;\n  if (isZoomIn && newSpanPercent < option.minSpan || !isZoomIn && newSpanPercent > option.maxSpan) {\n    return false;\n  }\n  if (minRange < option.minStart || maxRange > option.maxEnd) {\n    return false;\n  }\n  return true;\n}\nfunction getMultiplier(event) {\n  const ctrlMultiplier = event.ctrlKey ? 3 : 1;\n\n  // DeltaMode: 0 is pixel, 1 is line, 2 is page\n  // This is defined by the browser.\n  if (event.deltaMode === 1) {\n    return 1 * ctrlMultiplier;\n  }\n  if (event.deltaMode) {\n    return 10 * ctrlMultiplier;\n  }\n  return 0.2 * ctrlMultiplier;\n}\n\n/**\n * Get the scale ratio and if it's a zoom in or out from a wheel event.\n */\nfunction getWheelScaleRatio(event, step) {\n  const deltaY = -event.deltaY;\n  const multiplier = getMultiplier(event);\n  const scaledStep = step * multiplier * deltaY / 1000;\n  // Clamp the scale ratio between 0.1 and 1.9 so that the zoom is not too big or too small.\n  const scaleRatio = Math.min(Math.max(1 + scaledStep, 0.1), 1.9);\n  const isZoomIn = deltaY > 0;\n  return {\n    scaleRatio,\n    isZoomIn\n  };\n}\n\n/**\n * Get the scale ratio and if it's a zoom in or out from a pinch gesture.\n */\nfunction getPinchScaleRatio(curDiff, prevDiff, step) {\n  const scaledStep = step / 1000;\n  let scaleRatio = 0;\n  let isZoomIn = false;\n  const hasMoved = prevDiff > 0;\n  if (hasMoved && curDiff > prevDiff) {\n    // The distance between the two pointers has increased\n    scaleRatio = 1 + scaledStep;\n    isZoomIn = true;\n  }\n  if (hasMoved && curDiff < prevDiff) {\n    // The distance between the two pointers has decreased\n    scaleRatio = 1 - scaledStep;\n    isZoomIn = false;\n  }\n  return {\n    scaleRatio,\n    isZoomIn\n  };\n}\nfunction getDiff(eventCache) {\n  const [firstEvent, secondEvent] = eventCache;\n  return Math.hypot(firstEvent.pageX - secondEvent.pageX, firstEvent.pageY - secondEvent.pageY);\n}\n\n/**\n * Get the ratio of the point in the horizontal center of the area.\n */\nfunction getHorizontalCenterRatio(point, area) {\n  const {\n    left,\n    width\n  } = area;\n  return (point.x - left) / width;\n}\nfunction preventDefault(event) {\n  event.preventDefault();\n}\nfunction getVerticalCenterRatio(point, area) {\n  const {\n    top,\n    height\n  } = area;\n  return (point.y - top) / height * -1 + 1;\n}","map":{"version":3,"names":["React","useDrawingArea","useSvgRef","getSVGPoint","useZoom","zoomAtPoint","centerRatio","scaleRatio","currentZoomData","options","MIN_RANGE","minStart","MAX_RANGE","maxEnd","MIN_ALLOWED_SPAN","minSpan","minRange","start","maxRange","end","point","newMinRange","newMaxRange","minSpillover","maxSpillover","Math","abs","min","max","useSetupZoom","setZoomData","isZoomEnabled","setIsInteracting","drawingArea","svgRef","eventCacheRef","useRef","eventPrevDiff","interactionTimeoutRef","undefined","useEffect","element","current","wheelHandler","event","isPointInside","preventDefault","clearTimeout","window","setTimeout","prevZoomData","map","zoom","option","axisId","axisDirection","getHorizontalCenterRatio","getVerticalCenterRatio","isZoomIn","getWheelScaleRatio","step","isSpanValid","pointerDownHandler","push","pointerMoveHandler","index","findIndex","cachedEv","pointerId","length","firstEvent","curDiff","getDiff","newZoomData","getPinchScaleRatio","pointerUpHandler","splice","cachedEvent","type","addEventListener","removeEventListener","newSpanPercent","maxSpan","getMultiplier","ctrlMultiplier","ctrlKey","deltaMode","deltaY","multiplier","scaledStep","prevDiff","hasMoved","eventCache","secondEvent","hypot","pageX","pageY","area","left","width","x","top","height","y"],"sources":["C:/narendra/Reactjs/mini-expense-tracker/node_modules/@mui/x-charts-pro/context/ZoomProvider/useSetupZoom.js"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { useDrawingArea, useSvgRef } from '@mui/x-charts/hooks';\nimport { getSVGPoint } from '@mui/x-charts/internals';\nimport { useZoom } from \"./useZoom.js\";\n/**\n * Helper to get the range (in percents of a reference range) corresponding to a given scale.\n * @param centerRatio {number} The ratio of the point that should not move between the previous and next range.\n * @param scaleRatio {number} The target scale ratio.\n * @returns The range to display.\n */\nconst zoomAtPoint = (centerRatio, scaleRatio, currentZoomData, options) => {\n  const MIN_RANGE = options.minStart;\n  const MAX_RANGE = options.maxEnd;\n  const MIN_ALLOWED_SPAN = options.minSpan;\n  const minRange = currentZoomData.start;\n  const maxRange = currentZoomData.end;\n  const point = minRange + centerRatio * (maxRange - minRange);\n  let newMinRange = (minRange + point * (scaleRatio - 1)) / scaleRatio;\n  let newMaxRange = (maxRange + point * (scaleRatio - 1)) / scaleRatio;\n  let minSpillover = 0;\n  let maxSpillover = 0;\n  if (newMinRange < MIN_RANGE) {\n    minSpillover = Math.abs(newMinRange);\n    newMinRange = MIN_RANGE;\n  }\n  if (newMaxRange > MAX_RANGE) {\n    maxSpillover = Math.abs(newMaxRange - MAX_RANGE);\n    newMaxRange = MAX_RANGE;\n  }\n  if (minSpillover > 0 && maxSpillover > 0) {\n    return [MIN_RANGE, MAX_RANGE];\n  }\n  newMaxRange += minSpillover;\n  newMinRange -= maxSpillover;\n  newMinRange = Math.min(MAX_RANGE - MIN_ALLOWED_SPAN, Math.max(MIN_RANGE, newMinRange));\n  newMaxRange = Math.max(MIN_ALLOWED_SPAN, Math.min(MAX_RANGE, newMaxRange));\n  return [newMinRange, newMaxRange];\n};\nexport const useSetupZoom = () => {\n  const {\n    setZoomData,\n    isZoomEnabled,\n    options,\n    setIsInteracting\n  } = useZoom();\n  const drawingArea = useDrawingArea();\n  const svgRef = useSvgRef();\n  const eventCacheRef = React.useRef([]);\n  const eventPrevDiff = React.useRef(0);\n  const interactionTimeoutRef = React.useRef(undefined);\n  React.useEffect(() => {\n    const element = svgRef.current;\n    if (element === null || !isZoomEnabled) {\n      return () => {};\n    }\n    const wheelHandler = event => {\n      if (element === null) {\n        return;\n      }\n      const point = getSVGPoint(element, event);\n      if (!drawingArea.isPointInside(point)) {\n        return;\n      }\n      event.preventDefault();\n      if (interactionTimeoutRef.current) {\n        clearTimeout(interactionTimeoutRef.current);\n      }\n      setIsInteracting(true);\n      // Debounce transition to `isInteractive=false`.\n      // Useful because wheel events don't have an \"end\" event.\n      interactionTimeoutRef.current = window.setTimeout(() => {\n        setIsInteracting(false);\n      }, 166);\n      setZoomData(prevZoomData => {\n        return prevZoomData.map(zoom => {\n          const option = options[zoom.axisId];\n          if (!option) {\n            return zoom;\n          }\n          const centerRatio = option.axisDirection === 'x' ? getHorizontalCenterRatio(point, drawingArea) : getVerticalCenterRatio(point, drawingArea);\n          const {\n            scaleRatio,\n            isZoomIn\n          } = getWheelScaleRatio(event, option.step);\n          const [newMinRange, newMaxRange] = zoomAtPoint(centerRatio, scaleRatio, zoom, option);\n          if (!isSpanValid(newMinRange, newMaxRange, isZoomIn, option)) {\n            return zoom;\n          }\n          return {\n            axisId: zoom.axisId,\n            start: newMinRange,\n            end: newMaxRange\n          };\n        });\n      });\n    };\n    function pointerDownHandler(event) {\n      eventCacheRef.current.push(event);\n      setIsInteracting(true);\n    }\n    function pointerMoveHandler(event) {\n      if (element === null) {\n        return;\n      }\n      const index = eventCacheRef.current.findIndex(cachedEv => cachedEv.pointerId === event.pointerId);\n      eventCacheRef.current[index] = event;\n\n      // Not a pinch gesture\n      if (eventCacheRef.current.length !== 2) {\n        return;\n      }\n      const firstEvent = eventCacheRef.current[0];\n      const curDiff = getDiff(eventCacheRef.current);\n      setZoomData(prevZoomData => {\n        const newZoomData = prevZoomData.map(zoom => {\n          const option = options[zoom.axisId];\n          if (!option) {\n            return zoom;\n          }\n          const {\n            scaleRatio,\n            isZoomIn\n          } = getPinchScaleRatio(curDiff, eventPrevDiff.current, option.step);\n\n          // If the scale ratio is 0, it means the pinch gesture is not valid.\n          if (scaleRatio === 0) {\n            return zoom;\n          }\n          const point = getSVGPoint(element, firstEvent);\n          const centerRatio = option.axisDirection === 'x' ? getHorizontalCenterRatio(point, drawingArea) : getVerticalCenterRatio(point, drawingArea);\n          const [newMinRange, newMaxRange] = zoomAtPoint(centerRatio, scaleRatio, zoom, option);\n          if (!isSpanValid(newMinRange, newMaxRange, isZoomIn, option)) {\n            return zoom;\n          }\n          return {\n            axisId: zoom.axisId,\n            start: newMinRange,\n            end: newMaxRange\n          };\n        });\n        eventPrevDiff.current = curDiff;\n        return newZoomData;\n      });\n    }\n    function pointerUpHandler(event) {\n      eventCacheRef.current.splice(eventCacheRef.current.findIndex(cachedEvent => cachedEvent.pointerId === event.pointerId), 1);\n      if (eventCacheRef.current.length < 2) {\n        eventPrevDiff.current = 0;\n      }\n      if (event.type === 'pointerup' || event.type === 'pointercancel') {\n        setIsInteracting(false);\n      }\n    }\n    element.addEventListener('wheel', wheelHandler);\n    element.addEventListener('pointerdown', pointerDownHandler);\n    element.addEventListener('pointermove', pointerMoveHandler);\n    element.addEventListener('pointerup', pointerUpHandler);\n    element.addEventListener('pointercancel', pointerUpHandler);\n    element.addEventListener('pointerout', pointerUpHandler);\n    element.addEventListener('pointerleave', pointerUpHandler);\n\n    // Prevent zooming the entire page on touch devices\n    element.addEventListener('touchstart', preventDefault);\n    element.addEventListener('touchmove', preventDefault);\n    return () => {\n      element.removeEventListener('wheel', wheelHandler);\n      element.removeEventListener('pointerdown', pointerDownHandler);\n      element.removeEventListener('pointermove', pointerMoveHandler);\n      element.removeEventListener('pointerup', pointerUpHandler);\n      element.removeEventListener('pointercancel', pointerUpHandler);\n      element.removeEventListener('pointerout', pointerUpHandler);\n      element.removeEventListener('pointerleave', pointerUpHandler);\n      element.removeEventListener('touchstart', preventDefault);\n      element.removeEventListener('touchmove', preventDefault);\n      if (interactionTimeoutRef.current) {\n        clearTimeout(interactionTimeoutRef.current);\n      }\n    };\n  }, [svgRef, setZoomData, drawingArea, isZoomEnabled, options, setIsInteracting]);\n};\n\n/**\n * Checks if the new span is valid.\n */\nfunction isSpanValid(minRange, maxRange, isZoomIn, option) {\n  const newSpanPercent = maxRange - minRange;\n  if (isZoomIn && newSpanPercent < option.minSpan || !isZoomIn && newSpanPercent > option.maxSpan) {\n    return false;\n  }\n  if (minRange < option.minStart || maxRange > option.maxEnd) {\n    return false;\n  }\n  return true;\n}\nfunction getMultiplier(event) {\n  const ctrlMultiplier = event.ctrlKey ? 3 : 1;\n\n  // DeltaMode: 0 is pixel, 1 is line, 2 is page\n  // This is defined by the browser.\n  if (event.deltaMode === 1) {\n    return 1 * ctrlMultiplier;\n  }\n  if (event.deltaMode) {\n    return 10 * ctrlMultiplier;\n  }\n  return 0.2 * ctrlMultiplier;\n}\n\n/**\n * Get the scale ratio and if it's a zoom in or out from a wheel event.\n */\nfunction getWheelScaleRatio(event, step) {\n  const deltaY = -event.deltaY;\n  const multiplier = getMultiplier(event);\n  const scaledStep = step * multiplier * deltaY / 1000;\n  // Clamp the scale ratio between 0.1 and 1.9 so that the zoom is not too big or too small.\n  const scaleRatio = Math.min(Math.max(1 + scaledStep, 0.1), 1.9);\n  const isZoomIn = deltaY > 0;\n  return {\n    scaleRatio,\n    isZoomIn\n  };\n}\n\n/**\n * Get the scale ratio and if it's a zoom in or out from a pinch gesture.\n */\nfunction getPinchScaleRatio(curDiff, prevDiff, step) {\n  const scaledStep = step / 1000;\n  let scaleRatio = 0;\n  let isZoomIn = false;\n  const hasMoved = prevDiff > 0;\n  if (hasMoved && curDiff > prevDiff) {\n    // The distance between the two pointers has increased\n    scaleRatio = 1 + scaledStep;\n    isZoomIn = true;\n  }\n  if (hasMoved && curDiff < prevDiff) {\n    // The distance between the two pointers has decreased\n    scaleRatio = 1 - scaledStep;\n    isZoomIn = false;\n  }\n  return {\n    scaleRatio,\n    isZoomIn\n  };\n}\nfunction getDiff(eventCache) {\n  const [firstEvent, secondEvent] = eventCache;\n  return Math.hypot(firstEvent.pageX - secondEvent.pageX, firstEvent.pageY - secondEvent.pageY);\n}\n\n/**\n * Get the ratio of the point in the horizontal center of the area.\n */\nfunction getHorizontalCenterRatio(point, area) {\n  const {\n    left,\n    width\n  } = area;\n  return (point.x - left) / width;\n}\nfunction preventDefault(event) {\n  event.preventDefault();\n}\nfunction getVerticalCenterRatio(point, area) {\n  const {\n    top,\n    height\n  } = area;\n  return (point.y - top) / height * -1 + 1;\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}